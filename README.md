# gloose-15-418-Final-Project

For my final project, I would like to design a chess engine on the PSC machines using OpenMP. A chess engine is a program that can analyze chess moves based on their impact on the game several moves ahead. Ideally, the final product would be able to choose reasonably intelligent moves in a short amount of time, emulating the experience of playing against a human player.

As a very brief summary, chess is a two-player game where each player takes turns moving one piece at a time following a small set of rules. Over the course of the game, both players can capture their opponent’s pieces while positioning their own so as to deliver a “checkmate” by attacking the opponent’s king while leaving them no legal moves.
	
There are many ways to evaluate the goodness of a move. Perhaps the simplest is a system that assigns a point value to each piece; for example, if you capture your opponent’s knight, you win three points of material. This makes it a “good move”, unless it gives that player an opportunity to take your rook, earning them five points and leaving you worse off than you started. Therefore, a skilled player evaluates a move not just by its immediate impact, but by the best move their opponent could make in response, and their own best response to that, and so on. Considering all of these possibilities is the task of the chess engine.

From a computational perspective, this is difficult due to the sheer quantity of sequences  of moves that are possible. For example, if we (somewhat conservatively) assume that each player has 20 legal moves per turn (as is the case at the start of the game), then after both players have made their moves there are a total of 400 possible positions. This is just one turn; after two turns, with each player making two moves, we have 160,000 possibilities, and after three turns, we have 64,000,000. As we analyze moves further into the future, the numbers continue to grow exponentially, requiring a vast amount of computation. This is why I believe that a good parallel strategy could be useful for this application.

To some extent, different moves can be evaluated independently, which indicates that there is room for speedup. However, even having only just begun to think about this project, I do foresee some challenges. First, some parallelization strategies may suffer from workload imbalance; for example, if we were to assign each thread a separate initial move to evaluate, some moves may lead to positions with more possible future moves than others, e.g. if we capture a highly mobile piece or even produce a checkmate. We will also need to think about how the parallel threads synchronize over shared data; based on my initial research on this subject, it seems that the algorithm may involve maintaining a single tree of possible moves across all threads. I suspect that implementing some of the more advanced techniques to improve engine efficiency, such as pruning the tree to avoid further computation following an unpromising move, will exacerbate these issues.

Because it is already familiar from assignment 3, I intend to implement my project in OpenMP, running it on the GHC machines for testing and the PSC machines for assessing performance. Of course, on the basis of familiarity, I could have also chosen a CUDA-based implementation. However, I suspect that CUDA may not work well for this application, because I recall that it suffers a performance penalty from divergent execution, which I expect to be an important feature of my implementation. For example, the moves that are possible depend on which type of piece is at each position, which will likely be implemented in practice as a series of if statements to handle different piece types, which would be inefficient in CUDA. To my knowledge, this is not as much of a problem for OpenMP, since its focus is on multi-core parallelism rather than SIMD. Of course, in order to truly evaluate these options I would need to test an implementation on each and evaluate the speedups obtained; this is only my initial impression of how the two would compare.

(Note: At the time I wrote this project proposal, I had not even started assignment 4, as I was quite behind on a lot of course work, so I didn't feel that I understood MPI well enough to consider it as a possible platform for my project. My plans may or may not change upon completion of the assignment.)

At a minimum, a 75% target would be able receive a board state as input and output the best move in terms of raw material score looking several moves ahead (say, at least three), and use an algorithm and parallelization strategy that finds that move in an amount of time that is not too disruptive to gameplay (certainly no more than, say, 20 seconds, but I cannot yet judge what time frames are realistic). However, based on my initial research, there are a great number of optimizations that can be implemented both in terms of efficiency and correctness. What I plan to achieve for a 100% target would be a more advanced engine that can consider other factors aside from material to evaluate a move, such as the number of squares controlled by each player’s attacking pieces. In terms of efficiency, it would implement some optimizations (including pruning, as mentioned earlier) to further speed up computation time. I will require further research to learn more about optimizations in high-performance chess engines; an 125% solution would be a matter of experimenting with different techniques to improve efficiency and analysis even further. Of course, implicit in all of these goals is finding a way to parallelize my implementation to achieve reasonable speedup, though it is currently impossible for me to judge the extent of the speedup attainable.

The final demonstration could be done in the form of a live game between my engine and a computer opponent on chess.com or a similar website. There are, of course, multiple levels of difficulty to choose from, as well as choices for the limit on the turn timer for each player; my choices will depend on how far I get in terms of my targets, with more advanced solutions most likely being competitive with higher level bots under a shorter turn timer. This will be a good way to test my implementation during development as well.

Obviously, this week I have my hands full with assignment 4, so I do not intend to get started on the project until next week (week of 03/28). Even then, I have several deadlines and a midterm, but I hope to at least implement the data structures for representing a board state and determining which moves are possible. In the following week (week of 04/04), I would hope to implement a simple algorithm for evaluating all possible moves and choosing the best one, including parallelism with modest speedup. Next (week of 04/11), I will focus on the optimizations I have mentioned previously; during this week, I expect to at least implement tree pruning and one additional move evaluation heuristic (assuming, as I expect, that material score alone will not be sufficient for satisfactory performance against online chess bots). The week of 04/18 will be devoted to a combination of further refinements to my implementation and working on the final report. Finally, during the week of 04/25, I will ideally be finished with my code and will be solely focused on the report. Any remaining time will be spent preparing for the poster session.

Sources:

https://herculeschess.com/how-does-a-chess-engine-work/
The above website was a valuable reference to me in gaining a basic understanding of how chess engines work.


MILESTONE

See "15418 Milestone Report.pdf"

FINAL

See "report.pdf" for final report, and "project-presentation.mp4" for the final presentation.
